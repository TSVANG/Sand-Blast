<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sand Blast Ultimate</title>
    <style>
        /* –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è, —Å–∫—Ä–æ–ª–ª–∞ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é */
        * {
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        body {
            /* 5: –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç —Ç–µ–º–Ω–æ-–≥–æ–ª—É–±–æ–≥–æ —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑ –∏ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö (—Ü–µ–Ω—Ç—Ä —Ç–µ–º–Ω–µ–µ) */
            background: linear-gradient(180deg, #0f2040 0%, #050505 40%, #050505 60%, #0f2040 100%);
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            height: 100dvh; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å */
        #top-bar {
            width: 100%;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(31, 31, 46, 0.8); /* –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å */
            box-shadow: 0 2px 15px rgba(0,0,0,0.6);
            z-index: 10;
            flex-shrink: 0;
        }

        /* 6: –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å—á–µ—Ç–∞ */
        #score-container {
            width: 100%;
            max-width: 400px; /* –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —à–∏—Ä–∏–Ω—É */
            position: relative;
            height: 28px;
        }
        
        #score-bar-bg {
            width: 100%;
            height: 100%;
            background-color: #0f3460;
            border-radius: 14px;
            overflow: hidden;
            border: 2px solid #333;
        }

        #score-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        #score-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.95rem;
            font-weight: 800;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
            white-space: nowrap;
            z-index: 2;
        }

        /* –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å —Å –∏–≥—Ä–æ–π */
        #game-container-flex {
            flex-grow: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 5px;
        }

        /* –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ (–§–æ–Ω –∏–≥—Ä—ã - —á–µ—Ä–Ω—ã–π) */
        #game-wrapper {
            position: relative;
            border: 2px solid #0f3460;
            border-radius: 8px;
            background-color: #000; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            /* –†–∞–∑–º–µ—Ä—ã –∑–∞–¥–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ JS */
        }

        canvas#gameCanvas {
            display: block;
            border-radius: 4px;
            cursor: crosshair;
        }

        /* –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å */
        #controls-area {
            width: 100%;
            /* 6: –ù–µ –¥–∞–µ–º –≤—ã–ª–µ–∑–∞—Ç—å –∑–∞ —Ä–∞–º–∫–∏ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è –Ω–∞ —à–∏—Ä–æ–∫–∏—Ö —ç–∫—Ä–∞–Ω–∞—Ö */
            max-width: 100%; 
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            background: rgba(31, 31, 46, 0.9);
            border-top: 1px solid #333;
            flex-shrink: 0;
            padding-bottom: max(8px, env(safe-area-inset-bottom)); 
        }

        /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–æ–∫ –∏ —Ñ–∏–≥—É—Ä —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ —à–∏—Ä–∏–Ω–µ –∫–∞–Ω–≤–∞—Å–∞ (—Å–¥–µ–ª–∞–µ–º —á–µ—Ä–µ–∑ JS resize, –Ω–æ —Ç—É—Ç –∑–∞–¥–∞–¥–∏–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è) */
        .controls-inner {
            width: 100%;
            max-width: 500px; /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ */
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #pieces-container {
            width: 100%;
            height: 70px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: transparent;
            padding: 2px;
        }

        .piece-preview {
            background-color: transparent;
            transition: transform 0.1s;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
            /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ø—Ä–µ–≤—å—é, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å –≤–µ—Ä—Å—Ç–∫—É */
            max-height: 100%;
            max-width: 30%;
        }
        .piece-preview:active { transform: scale(0.95); }

        #buttons-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .icon-btn {
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            padding: 10px 5px;
            flex: 1;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 3px 0 rgba(0,0,0,0.3);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            white-space: nowrap;
        }
        
        .icon-btn:active {
            transform: translateY(3px);
            box-shadow: none;
        }

        #pause-btn { background: linear-gradient(to bottom, #4a4a5e, #2b2b3d); }
        #magic-btn { background: linear-gradient(to bottom, #d900ff, #9d00b8); }
        #rank-btn { background: linear-gradient(to bottom, #ffaa00, #cc8800); }

        #magic-btn.active {
            background: linear-gradient(45deg, #ff00de, #00f7ff);
            box-shadow: 0 0 20px #ff00de;
            animation: pulse 0.8s infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); box-shadow: 0 0 10px #ff00de; }
            to { transform: scale(1.05); box-shadow: 0 0 25px #ff00de; }
        }

        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200; /* –ü–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ */
            padding: 10px;
            text-align: center;
            backdrop-filter: blur(8px);
        }

        .modal-content {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 20px;
            border: 2px solid #e94560;
            width: 90%;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(233, 69, 96, 0.3);
        }

        .modal h2 { color: #e94560; margin-top: 0; font-size: 1.8rem; margin-bottom: 15px;}
        
        .modal-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            cursor: pointer;
            box-shadow: 0 4px 0 #081b33;
        }
        .modal-btn:active { transform: translateY(4px); box-shadow: none; }
        .modal-btn.primary { 
            background: linear-gradient(45deg, #e94560, #ff6b6b);
            box-shadow: 0 4px 0 #a12d40;
        }

        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 1.1rem;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #333;
            font-size: 0.9rem;
        }
        .leaderboard-item.me {
            color: #00f7ff;
            font-weight: bold;
            border: 2px solid #00f7ff;
            border-radius: 8px;
            background: rgba(0, 247, 255, 0.15);
        }

        #dragged-piece {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.5));
        }

        .popup-text {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 2.5em;
            text-shadow: 0 0 10px #ff00de;
            pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
            z-index: 50;
        }
        @keyframes floatUp {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(-60px) scale(1.2); }
        }

        #tutorial-canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: #000;
            margin: 10px auto;
            display: block;
            max-width: 100%;
        }
    </style>
</head>
<body>

    <audio id="snd_bg" loop> <source src="bg_music.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_pickup"> <source src="pickup.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_drop"> <source src="drop.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_combo"> <source src="combo.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_magic"> <source src="magic.mp3" type="audio/mpeg"> </audio>

    <div id="top-bar">
        <div id="score-container">
            <div id="score-bar-bg">
                <div id="score-bar-fill"></div>
            </div>
            <div id="score-text">0 / 25000</div>
        </div>
    </div>

    <!-- 6: –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å flex-grow –¥–ª—è –º–∞–∫—Å–∏–º–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—è -->
    <div id="game-container-flex">
        <div id="game-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <div id="controls-area">
        <div class="controls-inner">
            <div id="buttons-row">
                <button id="pause-btn" class="icon-btn">‚è∏Ô∏è –ú–µ–Ω—é</button>
                <button id="magic-btn" class="icon-btn">ü™Ñ –ú–∞–≥–∏—è</button>
                <button id="rank-btn" class="icon-btn">üèÜ –¢–æ–ø</button>
            </div>
            <div id="pieces-container"></div>
        </div>
    </div>

    <!-- –ú–µ–Ω—é -->
    <div id="menu-modal" class="modal">
        <div class="modal-content">
            <h2>–ú–µ–Ω—é</h2>
            <div class="toggle-row">
                <span>üîä –ó–≤—É–∫</span>
                <input type="checkbox" id="sound-toggle" checked>
            </div>
            <div class="toggle-row">
                <span>üì≥ –í–∏–±—Ä–∞—Ü–∏—è</span>
                <input type="checkbox" id="vibration-toggle" checked>
            </div>
            <hr style="border-color: #333; margin: 15px 0;">
            <div style="text-align: center; margin-bottom: 15px; font-size: 1em;">
                <div style="margin-bottom: 5px;">–ò–≥—Ä —Å—ã–≥—Ä–∞–Ω–æ: <span id="stat-games" style="color: #00f7ff">0</span></div>
                <div>–†–µ–∫–æ—Ä–¥: <span id="stat-record" style="color: #e94560">0</span></div>
            </div>
            <button class="modal-btn" id="tutorial-btn">üéì –û–±—É—á–µ–Ω–∏–µ</button>
            <button class="modal-btn primary" id="resume-btn">‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
            <button class="modal-btn" id="restart-menu-btn" style="background: #600f0f; margin-top: 15px;">üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        </div>
    </div>

    <!-- –†–µ–π—Ç–∏–Ω–≥ -->
    <div id="rank-modal" class="modal">
        <div class="modal-content">
            <h2>üèÜ –õ–∏–¥–µ—Ä—ã</h2>
            <div id="leaderboard-list" style="text-align: left; margin-bottom: 15px;"></div>
            <button class="modal-btn primary" id="close-rank-btn">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <!-- –û–±—É—á–µ–Ω–∏–µ -->
    <div id="tutorial-modal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <h2>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</h2>
            <canvas id="tutorial-canvas" width="200" height="250"></canvas>
            <p style="font-size: 0.9em; margin: 10px 0;">–ü–µ—Ä–µ—Ç–∞—â–∏ —Ñ–∏–≥—É—Ä—É -> –°–æ–±–µ—Ä–∏ –ª–∏–Ω–∏—é!</p>
            <p style="font-size: 0.9em; color: #aaa">–°–æ–±–µ—Ä–∏ 25,000 –æ—á–∫–æ–≤ –¥–ª—è —Ä–æ–∑–æ–≤–æ–≥–æ —Ü–≤–µ—Ç–∞!</p>
            <button class="modal-btn primary" id="close-tutorial-btn">–í—Å—ë –ø–æ–Ω—è—Ç–Ω–æ!</button>
        </div>
    </div>

    <!-- 2: Game Over —Å –∫–Ω–æ–ø–∫–æ–π -->
    <div id="gameover-modal" class="modal">
        <div class="modal-content">
            <h2 style="font-size: 2.2em">–ü—Ä–æ–∏–≥—Ä—ã—à</h2>
            <p style="font-size: 1.3em; margin: 20px 0;">–°—á—ë—Ç: <span id="final-score" style="color: #00f7ff">0</span></p>
            <button class="modal-btn primary" id="restart-btn">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const piecesContainer = document.getElementById('pieces-container');
        const scoreText = document.getElementById('score-text');
        const scoreFill = document.getElementById('score-bar-fill');
        const magicBtn = document.getElementById('magic-btn');
        const finalScoreSpan = document.getElementById('final-score');
        const statGamesSpan = document.getElementById('stat-games');
        const statRecordSpan = document.getElementById('stat-record');
        const gameWrapper = document.getElementById('game-wrapper');

        const sounds = {
            bg: document.getElementById('snd_bg'),
            pickup: document.getElementById('snd_pickup'),
            drop: document.getElementById('snd_drop'),
            combo: document.getElementById('snd_combo'),
            magic: document.getElementById('snd_magic')
        };

        const BLOCK_COLS = 15;
        const BLOCK_ROWS = 25;
        let MICRO_SCALE = 6; 
        let MICRO_COLS, MICRO_ROWS, MICRO_PIXEL_SIZE;
        
        const PHYSICS_ITERS_PER_FRAME = 3; 
        const CLEAR_ANIMATION_DURATION = 20;
        
        // 4: –õ–∏–Ω–∏—è —Å–º–µ—Ä—Ç–∏ –Ω–∏–∂–µ
        let GAME_OVER_LINE_ROW; // –ë—É–¥–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        
        const COLORS = { 
            1: '#FF3333', 2: '#33FF33', 3: '#3333FF', 4: '#FFFF33', 5: '#FF69B4'
        };
        
        const PIECES = [
            { shape: [[1, 1], [1, 1]] }, 
            { shape: [[1, 1, 1, 1]] }, 
            { shape: [[0, 1, 0], [1, 1, 1]] }, 
            { shape: [[1, 1, 0], [0, 1, 1]] }, 
            { shape: [[0, 1, 1], [1, 1, 0]] }, 
            { shape: [[1, 0, 0], [1, 1, 1]] }, 
            { shape: [[0, 0, 1], [1, 1, 1]] }
        ];

        let grid = [];
        let score = 0;
        let gameOver = false;
        let isPaused = false;
        let availablePieces = [];
        let selectedPieceIndex = -1;
        let isDragging = false;
        let draggedPieceElement = null;
        let isBoardStable = true;
        let isClearingLines = false;
        let pixelsToAnimate = [];
        let clearAnimationTimer = 0;
        let isMagicActive = false;
        let physicsFrameParity = 0;

        let settings = { sound: true, vibration: true };
        let stats = {
            gamesPlayed: parseInt(localStorage.getItem('sb_games') || '0'),
            record: parseInt(localStorage.getItem('sb_record') || '0')
        };

        // 6: –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è
        function resizeGame() {
            const topBar = document.getElementById('top-bar');
            const bottomBar = document.getElementById('controls-area');
            
            // –í—ã—á–∏—Å–ª—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ–µ –º–µ—Å—Ç–æ –¥–ª—è –∏–≥—Ä—ã
            const availableHeight = window.innerHeight - topBar.offsetHeight - bottomBar.offsetHeight - 10; // 10px –æ—Ç—Å—Ç—É–ø
            const availableWidth = window.innerWidth - 10; // 10px –æ—Ç—Å—Ç—É–ø –ø–æ –±–æ–∫–∞–º

            const aspectRatio = (BLOCK_COLS * MICRO_SCALE) / (BLOCK_ROWS * MICRO_SCALE);
            
            let displayHeight = availableHeight;
            let displayWidth = displayHeight * aspectRatio;

            // –ï—Å–ª–∏ –ø–æ —à–∏—Ä–∏–Ω–µ –Ω–µ –≤–ª–µ–∑–∞–µ—Ç
            if (displayWidth > availableWidth) {
                displayWidth = availableWidth;
                displayHeight = displayWidth / aspectRatio;
            }
            
            // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
            if (displayWidth < 150) displayWidth = 150;

            MICRO_COLS = BLOCK_COLS * MICRO_SCALE;
            MICRO_ROWS = BLOCK_ROWS * MICRO_SCALE;
            MICRO_PIXEL_SIZE = displayWidth / MICRO_COLS;
            
            // 4: –ö—Ä–∞—Å–Ω–∞—è –ª–∏–Ω–∏—è (–æ–ø—É—Å–∫–∞–µ–º –Ω–∏–∂–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞ 4 –ø–æ–ª–Ω—ã—Ö –±–ª–æ–∫–∞)
            GAME_OVER_LINE_ROW = MICRO_SCALE * 4; 

            canvas.width = Math.floor(MICRO_COLS * MICRO_PIXEL_SIZE);
            canvas.height = Math.floor(MICRO_ROWS * MICRO_PIXEL_SIZE);
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä—ã –∫ –æ–±–µ—Ä—Ç–∫–µ
            gameWrapper.style.width = canvas.width + 'px';
            gameWrapper.style.height = canvas.height + 'px';

            if (!grid || grid.length === 0) {
                 grid = Array.from({ length: MICRO_ROWS }, () => Array(MICRO_COLS).fill(0));
            }
            draw();
        }

        window.addEventListener('resize', resizeGame);

        function init() {
            resizeGame();
            grid = Array.from({ length: MICRO_ROWS }, () => Array(MICRO_COLS).fill(0));
            score = 0;
            gameOver = false;
            isPaused = false;
            isMagicActive = false;
            updateMagicState();
            updateScoreUI();
            generateNewPieces();
            
            // –°–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞
            document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
            
            document.body.addEventListener('click', () => {
                if(settings.sound && sounds.bg.paused) playSound('bg');
            }, {once: true});
            
            if (!gameLoop.isRunning) {
                gameLoop.isRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function gameLoop() {
            if (isPaused) {
                if(tutorialRunning) updateTutorial();
                requestAnimationFrame(gameLoop);
                return;
            }
            if (gameOver) return;

            if (!isClearingLines) {
                for (let i = 0; i < PHYSICS_ITERS_PER_FRAME; i++) {
                    if (!isBoardStable) {
                        updatePhysics();
                    } else {
                        break;
                    }
                }
                
                if (isBoardStable) {
                    const pixelsToClear = findConnectedLines();
                    if (pixelsToClear.length > 0) {
                        startClearAnimation(pixelsToClear);
                    }
                }
            }

            draw();
            if (!isClearingLines) checkGameOver();
            requestAnimationFrame(gameLoop);
        }
        gameLoop.isRunning = false;

        function updatePhysics() {
            let movedAny = false;
            physicsFrameParity = (physicsFrameParity + 1) % 2;

            for (let y = MICRO_ROWS - 2; y >= 0; y--) {
                const iterateLeftToRight = physicsFrameParity === 0;
                const startX = iterateLeftToRight ? 0 : MICRO_COLS - 1;
                const endX = iterateLeftToRight ? MICRO_COLS : -1;
                const stepX = iterateLeftToRight ? 1 : -1;

                for (let x = startX; x !== endX; x += stepX) {
                    if (grid[y][x] === 0) continue;
                    let moved = false;
                    if (grid[y + 1][x] === 0) {
                        grid[y + 1][x] = grid[y][x];
                        grid[y][x] = 0;
                        moved = true;
                    } else {
                        const dir = Math.random() < 0.5 ? 1 : -1;
                        if (checkAndMove(y, x, dir)) {
                            moved = true;
                        } else if (checkAndMove(y, x, -dir)) {
                            moved = true;
                        }
                    }
                    if (moved) movedAny = true;
                }
            }
            isBoardStable = !movedAny;
        }

        function checkAndMove(y, x, dir) {
            const newX = x + dir;
            if (newX >= 0 && newX < MICRO_COLS && grid[y + 1][newX] === 0) {
                grid[y + 1][newX] = grid[y][x];
                grid[y][x] = 0;
                return true;
            }
            return false;
        }

        function startClearAnimation(pixels) {
            isClearingLines = true;
            pixelsToAnimate = pixels;
            clearAnimationTimer = CLEAR_ANIMATION_DURATION;
            playSound('combo');
            vibrate(50);
            const points = Math.floor(pixels.length * 1.5);
            addScore(points);
            showPopupText(`+${points}`, canvas.width/2, canvas.height/2);
        }

        function findConnectedLines() {
            const visited = Array.from({ length: MICRO_ROWS }, () => Array(MICRO_COLS).fill(false));
            const allPixelsToClear = [];
            
            for (let y = 0; y < MICRO_ROWS; y++) {
                for (let x = 0; x < MICRO_COLS; x++) {
                    if (grid[y][x] !== 0 && !visited[y][x]) {
                        const color = Math.abs(grid[y][x]);
                        const group = [];
                        const queue = [[y, x]];
                        visited[y][x] = true;
                        let minX = x, maxX = x;
                        
                        while (queue.length > 0) {
                            const [curY, curX] = queue.shift();
                            group.push([curY, curX]);
                            minX = Math.min(minX, curX);
                            maxX = Math.max(maxX, curX);
                            
                            [
                                [0,1], [0,-1], [1,0], [-1,0],
                                [1,1], [1,-1], [-1,1], [-1,-1]
                            ].forEach(([dy, dx]) => {
                                const nY = curY + dy, nX = curX + dx;
                                if (nY >= 0 && nY < MICRO_ROWS && nX >= 0 && nX < MICRO_COLS &&
                                    !visited[nY][nX] && Math.abs(grid[nY][nX]) === color) {
                                    visited[nY][nX] = true;
                                    queue.push([nY, nX]);
                                }
                            });
                        }
                        
                        if (minX === 0 && maxX === MICRO_COLS - 1) {
                            allPixelsToClear.push(...group);
                        }
                    }
                }
            }
            return allPixelsToClear;
        }

        function checkGameOver() {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –ª–∏–Ω–∏–µ–π —Å–º–µ—Ä—Ç–∏
            if (isBoardStable) {
                for (let x = 0; x < MICRO_COLS; x++) {
                    if (grid[GAME_OVER_LINE_ROW][x] !== 0) {
                        endGame();
                        break;
                    }
                }
            }
        }

        // 2: –û–∫–Ω–æ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ
        function endGame() {
            gameOver = true;
            stats.gamesPlayed++;
            if (score > stats.record) stats.record = score;
            saveStats();
            finalScoreSpan.textContent = score;
            document.getElementById('gameover-modal').style.display = 'flex';
            vibrate([200, 100, 200]);
        }

        function generateNewPieces() {
            availablePieces = [];
            for (let i = 0; i < 3; i++) {
                const shape = PIECES[Math.floor(Math.random() * PIECES.length)].shape;
                let color;
                let r = Math.random();
                if (score >= 25000 && r > 0.9) {
                     color = 5;
                } else {
                    color = Math.floor(Math.random() * 4) + 1;
                }
                availablePieces.push({ shape, color });
            }
            drawPieceSelectors();
        }

        function activateMagic() {
            if (isMagicActive) {
                isMagicActive = false;
            } else {
                isMagicActive = true;
                showPopupText("–£–¥–∞–ª–∏—Ç—å —Ü–≤–µ—Ç!", canvas.width/2, canvas.height/3);
            }
            updateMagicState();
        }

        function updateMagicState() {
            if (isMagicActive) {
                magicBtn.classList.add('active');
                canvas.style.cursor = 'crosshair';
            } else {
                magicBtn.classList.remove('active');
                canvas.style.cursor = 'default';
            }
        }

        function handleCanvasClick(e) {
            if (!isMagicActive) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / MICRO_PIXEL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / MICRO_PIXEL_SIZE);
            
            if (x >= 0 && x < MICRO_COLS && y >= 0 && y < MICRO_ROWS) {
                const colorVal = Math.abs(grid[y][x]);
                if (colorVal !== 0) {
                    playSound('magic');
                    vibrate(50);
                    for(let r=0; r<MICRO_ROWS; r++){
                        for(let c=0; c<MICRO_COLS; c++){
                            if(Math.abs(grid[r][c]) === colorVal) grid[r][c] = 0;
                        }
                    }
                    isBoardStable = false;
                    isMagicActive = false;
                    updateMagicState();
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            let animProgress = 1.0;
            if (isClearingLines) {
                clearAnimationTimer--;
                animProgress = clearAnimationTimer / CLEAR_ANIMATION_DURATION;
                if (clearAnimationTimer <= 0) {
                    pixelsToAnimate.forEach(([y, x]) => { grid[y][x] = 0; });
                    isClearingLines = false;
                    pixelsToAnimate = [];
                    isBoardStable = false;
                }
            }

            for (let y = 0; y < MICRO_ROWS; y++) {
                for (let x = 0; x < MICRO_COLS; x++) {
                    const val = grid[y][x];
                    if (val !== 0) {
                        let color = COLORS[Math.abs(val)];
                        if (isClearingLines && pixelsToAnimate.some(p => p[0]===y && p[1]===x)) {
                             ctx.globalAlpha = animProgress;
                             const size = MICRO_PIXEL_SIZE * animProgress;
                             const offset = (MICRO_PIXEL_SIZE - size) / 2;
                             ctx.fillStyle = color;
                             ctx.fillRect(x * MICRO_PIXEL_SIZE + offset, y * MICRO_PIXEL_SIZE + offset, size, size);
                             ctx.globalAlpha = 1.0;
                        } else {
                            if (val < 0) color = darkenColor(color, -30);
                            ctx.fillStyle = color;
                            ctx.fillRect(x * MICRO_PIXEL_SIZE, y * MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE);
                        }
                    }
                }
            }

            // 4: –Ø—Ä–∫–∞—è –∫—Ä–∞—Å–Ω–∞—è –ª–∏–Ω–∏—è
            if (GAME_OVER_LINE_ROW) {
                ctx.beginPath();
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = "red";
                const yPos = GAME_OVER_LINE_ROW * MICRO_PIXEL_SIZE;
                ctx.moveTo(0, yPos);
                ctx.lineTo(canvas.width, yPos);
                ctx.stroke();
                ctx.shadowBlur = 0; // –°–±—Ä–æ—Å
            }
        }

        function drawPieceSelectors() {
            piecesContainer.innerHTML = '';
            availablePieces.forEach((piece, index) => {
                const preview = document.createElement('canvas');
                preview.className = 'piece-preview';
                preview.dataset.index = index;
                
                const blockSize = 16;
                const w = piece.shape[0].length * blockSize;
                const h = piece.shape.length * blockSize;
                preview.width = w;
                preview.height = h;
                
                const pCtx = preview.getContext('2d');
                pCtx.fillStyle = COLORS[piece.color];
                
                for(let y=0; y<piece.shape.length; y++){
                    for(let x=0; x<piece.shape[y].length; x++){
                        if(piece.shape[y][x]) {
                            pCtx.fillRect(x*blockSize, y*blockSize, blockSize-1, blockSize-1);
                            pCtx.fillStyle = 'rgba(255,255,255,0.2)';
                            pCtx.fillRect(x*blockSize, y*blockSize, blockSize, blockSize/3);
                            pCtx.fillStyle = COLORS[piece.color];
                        }
                    }
                }
                piecesContainer.appendChild(preview);
            });
        }

        function handleDragStart(e) {
            if (gameOver || isPaused || isClearingLines || isMagicActive) return;
            if (!e.target.classList.contains('piece-preview')) return;
            e.preventDefault();
            playSound('pickup');
            vibrate(20);

            selectedPieceIndex = parseInt(e.target.dataset.index);
            const piece = availablePieces[selectedPieceIndex];
            isDragging = true;
            
            draggedPieceElement = document.createElement('canvas');
            draggedPieceElement.id = 'dragged-piece';
            
            const realWidth = piece.shape[0].length * MICRO_SCALE * MICRO_PIXEL_SIZE;
            const realHeight = piece.shape.length * MICRO_SCALE * MICRO_PIXEL_SIZE;
            draggedPieceElement.width = realWidth;
            draggedPieceElement.height = realHeight;
            
            const dCtx = draggedPieceElement.getContext('2d');
            const baseColor = COLORS[piece.color];
            
            for(let y=0; y<piece.shape.length; y++){
                for(let x=0; x<piece.shape[y].length; x++){
                    if(piece.shape[y][x]){
                         for(let r=0; r<MICRO_SCALE; r++){
                            for(let c=0; c<MICRO_SCALE; c++){
                                dCtx.fillStyle = Math.random() > 0.5 ? baseColor : darkenColor(baseColor, -30);
                                dCtx.fillRect((x*MICRO_SCALE+c)*MICRO_PIXEL_SIZE, (y*MICRO_SCALE+r)*MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE);
                            }
                         }
                    }
                }
            }
            document.body.appendChild(draggedPieceElement);
            
            const touch = e.touches ? e.touches[0] : e;
            updateDragPosition(touch.clientX, touch.clientY, !!e.touches);
        }

        function handleDragMove(e) {
            if (!isDragging || !draggedPieceElement) return;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            updateDragPosition(touch.clientX, touch.clientY, !!e.touches);
        }
        
        function updateDragPosition(clientX, clientY, isTouch) {
            const rect = canvas.getBoundingClientRect();
            const dw = draggedPieceElement.width;
            const dh = draggedPieceElement.height;
            
            let targetX = clientX - dw / 2;
            
            // 3: –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è –º–æ–±–∏–ª–æ–∫
            // –ï—Å–ª–∏ —Ç–∞—á, –ø–æ–¥–Ω–∏–º–∞–µ–º —Ñ–∏–≥—É—Ä—É –≤—ã—à–µ –ø–∞–ª—å—Ü–∞ –Ω–∞ 1.5 –≤—ã—Å–æ—Ç—ã —Ñ–∏–≥—É—Ä—ã, —á—Ç–æ–±—ã –±—ã–ª–æ –≤–∏–¥–Ω–æ
            let targetY = isTouch ? (clientY - dh * 2.0) : (clientY - dh / 2);
            
            // –ì—Ä–∞–Ω–∏—Ü—ã Canvas –¥–ª—è –º–∞–≥–Ω–∏—Ç–∞
            const minX = rect.left;
            const maxX = rect.right - dw;

            // –ú–∞–≥–Ω–∏—Ç–∏–º –∫ –∫—Ä–∞—è–º –ø–æ X
            if (targetX < minX) targetX = minX;
            if (targetX > maxX) targetX = maxX;
            
            draggedPieceElement.style.left = targetX + 'px';
            draggedPieceElement.style.top = targetY + 'px';
            
            // –ü—Ä–æ–µ–∫—Ü–∏—è (–∫—É–¥–∞ —É–ø–∞–¥–µ—Ç)
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–Ω–≤–∞—Å–∞
            // –î–ª—è Y –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ —Ñ–∏–≥—É—Ä—ã –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏
            const centerX = targetX + dw / 2;
            const centerY = targetY + dh / 2;

            const relX = Math.round((targetX - rect.left) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            const relY = Math.round((targetY - rect.top) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            
            const piece = availablePieces[selectedPieceIndex];
            const valid = canPlacePiece(piece, relY, relX);
            
            draggedPieceElement.style.opacity = valid ? '1.0' : '0.5';
            draggedPieceElement.style.filter = valid 
                ? `drop-shadow(0 0 5px ${COLORS[piece.color]})` 
                : 'grayscale(100%)';
        }

        function handleDragEnd(e) {
            if (!isDragging) return;
            isDragging = false;

            const rect = canvas.getBoundingClientRect();
            const currentLeft = parseFloat(draggedPieceElement.style.left);
            const currentTop = parseFloat(draggedPieceElement.style.top);
            
            const dropX = Math.round((currentLeft - rect.left) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            const dropY = Math.round((currentTop - rect.top) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            
            const piece = availablePieces[selectedPieceIndex];
            
            if (canPlacePiece(piece, dropY, dropX)) {
                placePiece(piece, dropY, dropX);
                playSound('drop');
                vibrate(30);
                availablePieces.splice(selectedPieceIndex, 1);
                if (availablePieces.length === 0) generateNewPieces();
                drawPieceSelectors();
            }

            if (draggedPieceElement) draggedPieceElement.remove();
            draggedPieceElement = null;
        }

        function canPlacePiece(piece, dropY, dropX) {
            for(let y=0; y<piece.shape.length; y++){
                for(let x=0; x<piece.shape[y].length; x++){
                    if(piece.shape[y][x]){
                        const mx = (dropX + x) * MICRO_SCALE;
                        const my = (dropY + y) * MICRO_SCALE;
                        if (mx < 0 || mx + MICRO_SCALE > MICRO_COLS || 
                            my < 0 || my + MICRO_SCALE > MICRO_ROWS) return false;
                        for (let r=0; r<MICRO_SCALE; r+=MICRO_SCALE-1) {
                            for(let c=0; c<MICRO_SCALE; c+=MICRO_SCALE-1) {
                                if (grid[my+r][mx+c] !== 0) return false;
                            }
                        }
                    }
                }
            }
            return true;
        }

        function placePiece(piece, dropY, dropX) {
            isBoardStable = false;
            for(let y=0; y<piece.shape.length; y++){
                for(let x=0; x<piece.shape[y].length; x++){
                    if(piece.shape[y][x]){
                        const mx = (dropX + x) * MICRO_SCALE;
                        const my = (dropY + y) * MICRO_SCALE;
                        for(let r=0; r<MICRO_SCALE; r++){
                            for(let c=0; c<MICRO_SCALE; c++){
                                const val = piece.color;
                                grid[my+r][mx+c] = Math.random() > 0.5 ? val : -val;
                            }
                        }
                    }
                }
            }
        }

        function updateScoreUI() {
            let currentLevelBase = Math.floor(score / 25000) * 25000;
            let nextGoal = currentLevelBase + 25000;
            let progress = ((score - currentLevelBase) / 25000) * 100;
            
            scoreText.textContent = `${score} / ${nextGoal}`;
            scoreFill.style.width = `${Math.min(100, progress)}%`;
            
            if (currentLevelBase >= 25000) {
                scoreFill.style.background = 'linear-gradient(90deg, #FF00FF, #9d00b8)';
            } else {
                scoreFill.style.background = 'linear-gradient(90deg, #e94560, #ff6b6b)';
            }
        }

        function addScore(points) {
            score += points;
            updateScoreUI();
        }

        function showPopupText(text, x, y) {
            const el = document.createElement('div');
            el.className = 'popup-text';
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        // 1: –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –§–µ–π–∫–æ–≤—ã–π –¢–æ–ø
        function generateLeaderboard() {
            const names = ["–ê–ª–µ–∫—Å–µ–π", "–ú–∞—Ä–∏—è", "–ò–≤–∞–Ω", "–ï–ª–µ–Ω–∞", "–î–º–∏—Ç—Ä–∏–π", "–û–ª—å–≥–∞", "–°–µ—Ä–≥–µ–π", "–ê–Ω–Ω–∞", "–ù–∏–∫–æ–ª–∞–π", "–¢–∞—Ç—å—è–Ω–∞"];
            const list = [];
            
            // 1 –º–µ—Å—Ç–æ: 120-140 –º–ª–Ω
            let topScore = 120000000 + Math.floor(Math.random() * 20000000);
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–æ–ø 5 —Å —É–±—ã–≤–∞–Ω–∏–µ–º
            for(let i=0; i<5; i++) {
                let currentScore;
                if (i === 0) {
                    currentScore = topScore;
                } else if (i === 4) {
                    // 5 –º–µ—Å—Ç–æ: –æ–∫–æ–ª–æ 2 –º–ª–Ω
                    currentScore = 2000000 + Math.floor(Math.random() * 500000);
                } else {
                    // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –º–µ–∂–¥—É 1 –∏ 5 –º–µ—Å—Ç–æ–º
                    let factor = i / 4; // 0.25, 0.5, 0.75
                    // –ü—Ä–æ—Å—Ç–æ —Å–¥–µ–ª–∞–µ–º —Ä–µ–∑–∫–∏–π —Å–ø–∞–¥
                    currentScore = Math.floor(topScore / Math.pow(3, i)); 
                }

                list.push({
                    rank: i+1,
                    name: names[i],
                    score: currentScore.toLocaleString('ru-RU')
                });
            }

            // 1: –§–æ—Ä–º—É–ª–∞ –º–µ—Å—Ç–∞ –∏–≥—Ä–æ–∫–∞
            // 10000 –∏–≥—Ä–æ–∫–æ–≤, –∫–∞–∂–¥—ã–µ 800 –æ—á–∫–æ–≤ +1 –º–µ—Å—Ç–æ
            let playerRank = 10000 - Math.floor(score / 800);
            if (playerRank < 1) playerRank = 1; // –ù–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã—à–µ 1
            if (playerRank > 10000) playerRank = 10000;

            const playerEntry = { rank: playerRank, name: "–í—ã", score: score.toLocaleString('ru-RU'), isMe: true };
            
            const container = document.getElementById('leaderboard-list');
            container.innerHTML = '';
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ø 5 + –∏–≥—Ä–æ–∫–∞
            let displayList = [...list];
            // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –Ω–µ –ø–æ–ø–∞–ª –≤ —Ç–æ–ø 5, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ –∫–æ–Ω–µ—Ü
            if (playerRank > 5) {
                displayList.push({ rank: "...", name: "", score: "" }); // –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
                displayList.push(playerEntry);
            } else {
                // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –≤ —Ç–æ–ø–µ (—Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏), –∑–∞–º–µ–Ω—è–µ–º –±–æ—Ç–∞ (—É–ø—Ä–æ—â–µ–Ω–æ)
                 // –í –¥–∞–Ω–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∂–µ–º –µ–≥–æ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π –µ—Å–ª–∏ –æ–Ω –∫—Ä—É—Ç, –∏–ª–∏ –æ–Ω –ø—Ä–æ—Å—Ç–æ –≤–∏–¥–∏—Ç —Ç–æ–ø –±–æ—Ç–æ–≤
            }

            displayList.forEach(item => {
                const div = document.createElement('div');
                div.className = `leaderboard-item ${item.isMe ? 'me' : ''}`;
                if (item.rank === "...") {
                     div.innerHTML = `<span>...</span>`;
                     div.style.border = "none";
                } else {
                    div.innerHTML = `
                        <span>#${item.rank} ${item.rank===1?'üèÜ':''} ${item.name}</span>
                        <span>${item.score}</span>
                    `;
                }
                container.appendChild(div);
            });
        }

        function darkenColor(hex, amount) {
            let usePound = false;
            if (hex[0] == "#") { hex = hex.slice(1); usePound = true; }
            let num = parseInt(hex, 16);
            let r = (num >> 16) + amount;
            let b = ((num >> 8) & 0x00FF) + amount;
            let g = (num & 0x0000FF) + amount;
            if (r > 255) r = 255; else if (r < 0) r = 0;
            if (b > 255) b = 255; else if (b < 0) b = 0;
            if (g > 255) g = 255; else if (g < 0) g = 0;
            return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6,'0');
        }

        function playSound(name) {
            if (settings.sound && sounds[name]) {
                sounds[name].currentTime = 0;
                sounds[name].play().catch(e => {});
            }
        }

        function vibrate(ms) {
            if (settings.vibration && navigator.vibrate) {
                navigator.vibrate(ms);
            }
        }

        function saveStats() {
            localStorage.setItem('sb_games', stats.gamesPlayed);
            localStorage.setItem('sb_record', stats.record);
        }
        
        document.addEventListener('contextmenu', event => event.preventDefault());

        magicBtn.addEventListener('click', activateMagic);
        canvas.addEventListener('click', handleCanvasClick);
        
        document.getElementById('pause-btn').addEventListener('click', () => {
            isPaused = true;
            tutorialRunning = false; 
            document.getElementById('stat-games').textContent = stats.gamesPlayed;
            document.getElementById('stat-record').textContent = stats.record;
            document.getElementById('menu-modal').style.display = 'flex';
        });

        document.getElementById('resume-btn').addEventListener('click', () => {
            document.getElementById('menu-modal').style.display = 'none';
            isPaused = false;
        });

        document.getElementById('restart-menu-btn').addEventListener('click', init);
        document.getElementById('restart-btn').addEventListener('click', init);

        document.getElementById('rank-btn').addEventListener('click', () => {
            isPaused = true;
            generateLeaderboard();
            document.getElementById('rank-modal').style.display = 'flex';
        });
        document.getElementById('close-rank-btn').addEventListener('click', () => {
            document.getElementById('rank-modal').style.display = 'none';
            isPaused = false;
        });

        // –û–±—É—á–µ–Ω–∏–µ
        let tutorialRunning = false;
        let tutCanvas, tutCtx, tutGrid;
        let tutTimer = 0;
        let tutState = 0; 

        function initTutorial() {
            tutCanvas = document.getElementById('tutorial-canvas');
            tutCtx = tutCanvas.getContext('2d');
            tutGrid = Array.from({ length: 40 }, () => Array(25).fill(0));
            tutorialRunning = true;
            tutState = 0;
            tutTimer = 0;
            requestAnimationFrame(updateTutorial);
        }

        function updateTutorial() {
            if (!tutorialRunning) return;

            tutCtx.fillStyle = '#000';
            tutCtx.fillRect(0, 0, tutCanvas.width, tutCanvas.height);
            
            tutTimer++;
            const PIXEL_SIZE = 8;

            if (tutState === 0 && tutTimer > 20) {
                for(let y=0; y<5; y++) {
                    for(let x=5; x<15; x++) {
                        tutGrid[y][x] = 2;
                    }
                }
                tutState = 1;
                tutTimer = 0;
            }
            
            if (tutState === 1) {
                let moved = false;
                for (let y = 38; y >= 0; y--) {
                    for (let x = 0; x < 25; x++) {
                        if (tutGrid[y][x] !== 0) {
                             if (tutGrid[y+1] && tutGrid[y+1][x] === 0) {
                                 tutGrid[y+1][x] = tutGrid[y][x];
                                 tutGrid[y][x] = 0;
                                 moved = true;
                             } else if (tutGrid[y+1]) {
                                 const dir = Math.random() < 0.5 ? 1 : -1;
                                 if (x+dir>=0 && x+dir<25 && tutGrid[y+1][x+dir] === 0) {
                                     tutGrid[y+1][x+dir] = tutGrid[y][x];
                                     tutGrid[y][x] = 0;
                                     moved = true;
                                 }
                             }
                        }
                    }
                }
                if (!moved && tutTimer > 60) {
                    tutState = 2;
                    tutTimer = 0;
                }
            }

            if (tutState === 2) {
                if (Math.floor(tutTimer / 10) % 2 === 0) {
                     tutCtx.globalAlpha = 0.5;
                }
                if (tutTimer > 60) {
                    tutGrid = Array.from({ length: 40 }, () => Array(25).fill(0)); 
                    tutState = 0;
                    tutTimer = 0;
                    tutCtx.globalAlpha = 1.0;
                }
            }

            for (let y = 0; y < 40; y++) {
                for (let x = 0; x < 25; x++) {
                    if (tutGrid[y][x] !== 0) {
                        tutCtx.fillStyle = '#33FF33';
                        tutCtx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                    }
                }
            }
            tutCtx.globalAlpha = 1.0;

            if (tutorialRunning) requestAnimationFrame(updateTutorial);
        }

        document.getElementById('tutorial-btn').addEventListener('click', () => {
            document.getElementById('menu-modal').style.display = 'none';
            document.getElementById('tutorial-modal').style.display = 'flex';
            initTutorial();
        });
        document.getElementById('close-tutorial-btn').addEventListener('click', () => {
             document.getElementById('tutorial-modal').style.display = 'none';
             document.getElementById('menu-modal').style.display = 'flex';
             tutorialRunning = false;
        });

        document.getElementById('sound-toggle').addEventListener('change', (e) => {
            settings.sound = e.target.checked;
            if(settings.sound) sounds.bg.play(); else sounds.bg.pause();
        });
        document.getElementById('vibration-toggle').addEventListener('change', (e) => {
            settings.vibration = e.target.checked;
        });

        piecesContainer.addEventListener('mousedown', handleDragStart);
        piecesContainer.addEventListener('touchstart', handleDragStart, { passive: false });
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);

        init();
    </script>
</body>
</html>
