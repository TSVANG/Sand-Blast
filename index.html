<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sand Blast Ultimate</title>
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        body {
            background: linear-gradient(180deg, #0f2040 0%, #050505 40%, #050505 60%, #0f2040 100%);
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            height: 100dvh; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* –ò–∫–æ–Ω–∫–∏ SVG */
        .icon-svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
            vertical-align: middle;
            margin-right: 5px;
        }

        #top-bar {
            background: transparent;
            padding: 5px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            flex-shrink: 0;
            width: 100%;
        }

        #score-container {
            width: 90%;
            max-width: 400px;
            position: relative;
            height: 24px;
        }
        
        #score-bar-bg {
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #score-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            transition: width 0.3s ease-out;
            box-shadow: 0 0 8px rgba(233, 69, 96, 0.4);
        }

        #score-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            font-weight: 800;
            text-shadow: 1px 1px 2px #000;
            white-space: nowrap;
            z-index: 2;
        }

        #game-container-flex {
            flex: 1 1 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
            width: 100%;
            overflow: hidden;
            min-height: 0;
        }

        #game-wrapper {
            position: relative;
            border: 2px solid #0f3460;
            border-radius: 8px;
            background-color: #000; 
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transition: box-shadow 0.3s, border-color 0.3s;
        }
        
        #game-wrapper.magic-active {
            border-color: #d900ff;
            box-shadow: 0 0 30px #d900ff, inset 0 0 20px #d900ff;
            cursor: crosshair;
        }

        canvas#gameCanvas {
            display: block;
            border-radius: 4px;
        }

        #controls-area {
            background: transparent;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px 0;
            border-top: none;
            flex-shrink: 0;
            width: 100%;
            max-width: 500px;
            padding-bottom: max(10px, env(safe-area-inset-bottom)); 
        }

        #buttons-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            width: 95%;
            margin: 0 auto;
        }

        .icon-btn {
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            padding: 12px 5px;
            flex: 1;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            white-space: nowrap;
            transition: all 0.1s;
            text-transform: uppercase;
        }
        
        .icon-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* –¶–≤–µ—Ç–∞ –∫–Ω–æ–ø–æ–∫ */
        #menu-btn { background: linear-gradient(to bottom, #4a4a5e, #2b2b3d); }
        #magic-btn { background: linear-gradient(to bottom, #d900ff, #9d00b8); }
        #rank-btn { background: linear-gradient(to bottom, #ffaa00, #cc8800); }
        #games-btn { background: linear-gradient(to bottom, #00c6ff, #0072ff); }

        #magic-btn.active {
            background: linear-gradient(45deg, #ff00de, #7a00ff);
            box-shadow: 0 0 25px #ff00de;
            animation: magicPulse 0.6s infinite alternate;
            border: 2px solid #fff;
            transform: scale(1.05);
            z-index: 20;
        }
        
        @keyframes magicPulse {
            from { box-shadow: 0 0 10px #ff00de; }
            to { box-shadow: 0 0 30px #ff00de, 0 0 10px #fff; }
        }
        
        .ad-icon {
            display: inline-block;
            background: #fff;
            color: #d900ff;
            border-radius: 3px;
            padding: 0 3px;
            font-size: 0.7em;
            margin-left: 4px;
            vertical-align: middle;
            font-weight: 900;
        }

        #pieces-container {
            width: 100%;
            height: 80px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: transparent;
        }

        .piece-preview {
            background-color: transparent;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
            max-width: 30%; 
            max-height: 90%;
            touch-action: none;
        }
        .piece-preview:active { transform: scale(0.95); }

        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 10px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 20px;
            border: 2px solid #e94560;
            width: 90%;
            max-width: 340px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(233, 69, 96, 0.4);
            color: #fff;
        }

        .modal h2 { color: #e94560; margin-top: 0; font-size: 1.8rem; margin-bottom: 15px;}
        
        .modal-btn {
            display: block;
            width: 100%;
            padding: 14px;
            margin: 10px 0;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #081b33;
            transition: transform 0.1s;
        }
        .modal-btn:active { transform: translateY(4px); box-shadow: none; }
        .modal-btn.primary { 
            background: linear-gradient(45deg, #e94560, #ff6b6b);
            box-shadow: 0 4px 0 #a12d40;
        }

        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 1.1rem;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #333;
            font-size: 1rem;
        }
        .leaderboard-item.me {
            color: #00f7ff;
            font-weight: bold;
            border: 1px solid #00f7ff;
            border-radius: 8px;
            background: rgba(0, 247, 255, 0.15);
        }

        /* –°—Ç–∏–ª–∏ –∫–∞—Ç–∞–ª–æ–≥–∞ –∏–≥—Ä */
        .games-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .game-card {
            background: #252540;
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: transform 0.1s;
            border: 1px solid #444;
        }
        .game-card:active { transform: scale(0.95); }
        .game-img {
            width: 100%;
            aspect-ratio: 1/1;
            background: #000;
            border-radius: 8px;
            margin-bottom: 8px;
            object-fit: cover;
        }
        .game-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: #fff;
        }

        #dragged-piece {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            filter: drop-shadow(0 0 15px rgba(255,255,255,0.6));
        }

        .popup-text {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 2.5em;
            text-shadow: 0 0 10px #ff00de;
            pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
            z-index: 50;
        }
        @keyframes floatUp {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(-60px) scale(1.2); }
        }

        #tutorial-canvas {
            border: 2px solid #444;
            border-radius: 8px;
            background: #000;
            margin: 10px auto;
            display: block;
            max-width: 100%;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        #tutorial-text {
            font-size: 1.1rem;
            color: #00f7ff;
            margin: 10px 0;
            min-height: 1.5em;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 247, 255, 0.5);
        }
    </style>
</head>
<body>

    <!-- –ó–≤—É–∫–∏ -->
    <audio id="snd_bg" loop preload="auto"> <source src="bg_music.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_pickup" preload="auto"> <source src="pickup.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_drop" preload="auto"> <source src="drop.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_combo" preload="auto"> <source src="combo.mp3" type="audio/mpeg"> </audio>
    <audio id="snd_magic" preload="auto"> <source src="magic.mp3" type="audio/mpeg"> </audio>

    <!-- SVG –ò–∫–æ–Ω–∫–∏ (—Å–ø—Ä—è—Ç–∞–Ω—ã) -->
    <svg style="display: none;">
        <symbol id="icon-pause" viewBox="0 0 24 24"><path d="M6 4h4v16H6zm8 0h4v16h-4z"/></symbol>
        <symbol id="icon-magic" viewBox="0 0 24 24"><path d="M7.5 5.6L10 7 8.6 4.5 10 2 7.5 3.4 5 2l1.4 2.5L5 7zm12 9.8L17 13l2.5 1.4L17 15.8 19.5 17.2 22 15.8 20.6 13.3zM22 2l-2.5 1.4L17 2l1.4 2.5L17 7l2.5-1.4L22 7l-1.4-2.5zM11.2 15.5l-5.3 5.3a1.5 1.5 0 0 1-2.1 0 1.5 1.5 0 0 1 0-2.1l5.3-5.3a.9.9 0 0 1 1.3 0l.8.8a.9.9 0 0 1 0 1.3zM19 9l-2.2-2.2a1 1 0 0 0-1.4 0l-7.7 7.7a1.6 1.6 0 0 0 0 2.3l2.2 2.2a1.6 1.6 0 0 0 2.3 0l7.7-7.7a1 1 0 0 0 0-1.4z"/></symbol>
        <symbol id="icon-cup" viewBox="0 0 24 24"><path d="M17 2H7C5.9 2 5 2.9 5 4v2c0 3.3 2.7 6 6 6s6-2.7 6-6V4c0-1.1-.9-2-2-2zm-5 6c-1.7 0-3-1.3-3-3V4h6v2c0 1.7-1.3 3-3 3zM19 4h2v2c0 2.8-2.2 5-5 5v2c0 1.7-1.3 3-3 3s-3-1.3-3-3v-2c-2.8 0-5-2.2-5-5V4h2v2c0 1.7 1.3 3 3 3s3-1.3 3-3V4zm-7 16h10v2H5v-2z"/></symbol>
        <symbol id="icon-gamepad" viewBox="0 0 24 24"><path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-10 7H8v3H6v-3H3v-2h3V8h2v3h3v2zm4.5 2c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm4-3c-.8 0-1.5-.7-1.5-1.5S18.7 9 19.5 9s1.5.7 1.5 1.5-.7 1.5-1.5 1.5z"/></symbol>
    </svg>

    <div id="top-bar">
        <div id="score-container">
            <div id="score-bar-bg">
                <div id="score-bar-fill"></div>
            </div>
            <div id="score-text">0 / 25000</div>
        </div>
    </div>

    <div id="game-container-flex">
        <div id="game-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <div id="controls-area">
        <div id="buttons-row">
            <!-- 6) –ò–∫–æ–Ω–∫–∏ –≤–º–µ—Å—Ç–æ —ç–º–æ–¥–∑–∏ -->
            <button id="menu-btn" class="icon-btn"><svg class="icon-svg"><use xlink:href="#icon-pause"/></svg></button>
            <button id="magic-btn" class="icon-btn"><svg class="icon-svg"><use xlink:href="#icon-magic"/></svg> <span class="ad-icon">AD</span></button>
            <button id="rank-btn" class="icon-btn"><svg class="icon-svg"><use xlink:href="#icon-cup"/></svg></button>
            <!-- 3) –ö–Ω–æ–ø–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ -->
            <button id="games-btn" class="icon-btn"><svg class="icon-svg"><use xlink:href="#icon-gamepad"/></svg></button>
        </div>
        <div id="pieces-container"></div>
    </div>

    <!-- –ú–µ–Ω—é -->
    <div id="menu-modal" class="modal">
        <div class="modal-content">
            <h2>–ú–µ–Ω—é</h2>
            <div class="toggle-row">
                <span>üîä –ó–≤—É–∫</span>
                <input type="checkbox" id="sound-toggle" checked>
            </div>
            <div class="toggle-row">
                <span>üì≥ –í–∏–±—Ä–∞—Ü–∏—è</span>
                <input type="checkbox" id="vibration-toggle" checked>
            </div>
            <hr style="border-color: #333; margin: 15px 0;">
            <div style="text-align: center; margin-bottom: 15px;">
                <div style="margin-bottom: 5px;">–ò–≥—Ä —Å—ã–≥—Ä–∞–Ω–æ: <span id="stat-games" style="color: #00f7ff">0</span></div>
                <div>–†–µ–∫–æ—Ä–¥: <span id="stat-record" style="color: #e94560">0</span></div>
            </div>
            <button class="modal-btn" id="tutorial-btn">üéì –û–±—É—á–µ–Ω–∏–µ</button>
            <button class="modal-btn primary" id="resume-btn">‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
            <button class="modal-btn" id="restart-menu-btn" style="background: #600f0f; margin-top: 15px;">üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        </div>
    </div>

    <!-- –û–∫–Ω–æ "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–≥—Ä—É?" -->
    <div id="welcome-modal" class="modal">
        <div class="modal-content">
            <h2>Sand Blast</h2>
            <p style="margin: 20px 0; color: #aaa">–ù–∞–π–¥–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –æ–±–ª–∞–∫–µ</p>
            <button class="modal-btn primary" id="welcome-continue-btn">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            <button class="modal-btn" id="welcome-new-btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        </div>
    </div>

    <div id="rank-modal" class="modal">
        <div class="modal-content">
            <h2>üèÜ –õ–∏–¥–µ—Ä—ã</h2>
            <div id="leaderboard-list" style="text-align: left; margin-bottom: 15px;"></div>
            <button class="modal-btn primary" id="close-rank-btn">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <!-- 3) –ö–∞—Ç–∞–ª–æ–≥ –ò–≥—Ä -->
    <div id="games-modal" class="modal">
        <div class="modal-content">
            <h2>üéÆ –ú–æ–∏ –ò–≥—Ä—ã</h2>
            <div id="games-list" class="games-grid">
                <!-- JS –∑–∞–ø–æ–ª–Ω–∏—Ç —ç—Ç–æ -->
            </div>
            <button class="modal-btn primary" id="close-games-btn">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <!-- 2) –û–±—É—á–µ–Ω–∏–µ —Å –¥–µ—Ç–∞–ª—å–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–µ–π -->
    <div id="tutorial-modal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
            <h2>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</h2>
            <canvas id="tutorial-canvas" width="300" height="300"></canvas>
            <div id="tutorial-text">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
            <button class="modal-btn primary" id="close-tutorial-btn">–í—Å—ë –ø–æ–Ω—è—Ç–Ω–æ!</button>
        </div>
    </div>

    <div id="gameover-modal" class="modal">
        <div class="modal-content">
            <h2 style="font-size: 2.2em">–ü—Ä–æ–∏–≥—Ä—ã—à</h2>
            <p style="font-size: 1.3em; margin: 20px 0;">–°—á—ë—Ç: <span id="final-score" style="color: #00f7ff">0</span></p>
            <button class="modal-btn primary" id="restart-btn">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        </div>
    </div>

    <script>
        const vkBridge = window.vkBridge;
        vkBridge.send('VKWebAppInit').catch(console.log);

        // --- 3, 5) –ö–ê–¢–ê–õ–û–ì –ò–ì–† ---
        // –ó–∞–ø–æ–ª–Ω–∏—Ç–µ —ç—Ç–æ—Ç –º–∞—Å—Å–∏–≤ –≤–∞—à–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        // –ö–∞—Ä—Ç–∏–Ω–∫–∏ –ª—É—á—à–µ –≤—Å–µ–≥–æ JPG –∏–ª–∏ PNG, 512x512px.
        // –ü–æ–ª–æ–∂–∏—Ç–µ –∏—Ö –≤ –∫–æ—Ä–µ–Ω—å –ø–∞–ø–∫–∏ –ø—Ä–æ–µ–∫—Ç–∞.
        const GAMES_CATALOG = [
            { id: 123456, name: "–ò–≥—Ä–∞ 1", img: "game1.jpg" }, 
            { id: 234567, name: "–ò–≥—Ä–∞ 2", img: "game2.jpg" },
            { id: 345678, name: "–ò–≥—Ä–∞ 3", img: "game3.jpg" },
            { id: 456789, name: "–ò–≥—Ä–∞ 4", img: "game4.jpg" },
            { id: 567890, name: "–ò–≥—Ä–∞ 5", img: "game5.jpg" }
        ];

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const piecesContainer = document.getElementById('pieces-container');
        const scoreText = document.getElementById('score-text');
        const scoreFill = document.getElementById('score-bar-fill');
        const magicBtn = document.getElementById('magic-btn');
        const finalScoreSpan = document.getElementById('final-score');
        const statGamesSpan = document.getElementById('stat-games');
        const statRecordSpan = document.getElementById('stat-record');
        const gameWrapper = document.getElementById('game-wrapper');
        const topBar = document.getElementById('top-bar');
        const controlsArea = document.getElementById('controls-area');
        const tutorialTextDiv = document.getElementById('tutorial-text');

        const sounds = {
            bg: document.getElementById('snd_bg'),
            pickup: document.getElementById('snd_pickup'),
            drop: document.getElementById('snd_drop'),
            combo: document.getElementById('snd_combo'),
            magic: document.getElementById('snd_magic')
        };

        function preloadSounds() {
            Object.values(sounds).forEach(snd => { snd.load(); snd.volume = 0.5; });
        }
        preloadSounds();

        const MICRO_COLS = 80;
        const MICRO_ROWS = 100;
        const GAME_OVER_LINE_ROW = 20; 
        let MICRO_SCALE = 6; 
        let MICRO_PIXEL_SIZE;
        const PHYSICS_ITERS_PER_FRAME = 3; 
        const CLEAR_ANIMATION_DURATION = 20;
        
        // 1) –ù–æ–≤—ã–µ —Ü–≤–µ—Ç–∞ –∏ –ø–æ—Ä–æ–≥–∏
        const COLORS = { 
            1: '#FF3333', // –ö—Ä–∞—Å–Ω—ã–π (–°—Ç–∞—Ä—Ç)
            2: '#33FF33', // –ó–µ–ª–µ–Ω—ã–π (–°—Ç–∞—Ä—Ç)
            3: '#3333FF', // –°–∏–Ω–∏–π (–°—Ç–∞—Ä—Ç)
            4: '#FFFF33', // –ñ–µ–ª—Ç—ã–π (–°—Ç–∞—Ä—Ç)
            // –ù–æ–≤—ã–µ:
            5: '#FF69B4', // –†–æ–∑–æ–≤—ã–π (> 25k)
            6: '#33FFFF', // –°–≤–µ—Ç–ª–æ-–≥–æ–ª—É–±–æ–π (> 50k)
            7: '#FF9933', // –°–≤–µ—Ç–ª–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π (> 75k)
            8: '#9933FF'  // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π (> 100k)
        };
        
        const PIECES = [
            { shape: [[1, 1], [1, 1]] }, { shape: [[1, 1, 1, 1]] }, { shape: [[0, 1, 0], [1, 1, 1]] }, 
            { shape: [[1, 1, 0], [0, 1, 1]] }, { shape: [[0, 1, 1], [1, 1, 0]] }, 
            { shape: [[1, 0, 0], [1, 1, 1]] }, { shape: [[0, 0, 1], [1, 1, 1]] }
        ];

        let grid = [], score = 0, gameOver = false, isPaused = false;
        let availablePieces = [], selectedPieceIndex = -1, isDragging = false;
        let draggedPieceElement = null, isBoardStable = true, isClearingLines = false;
        let pixelsToAnimate = [], clearAnimationTimer = 0, isMagicActive = false;
        let physicsFrameParity = 0, gameLoopId = null, bannerHeight = 0;
        let settings = { sound: true, vibration: true };
        let stats = { gamesPlayed: 0, record: 0 };

        // --- 4) –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø (–û–ë–õ–ê–ö–û –í–ö) ---
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –µ–¥–∏–Ω—ã–π –∫–ª—é—á –¥–ª—è –≤—Å–µ–≥–æ, —á—Ç–æ–±—ã –ø—Ä–∏ —Å–º–µ–Ω–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –ø–æ–¥—Ç—è–≥–∏–≤–∞–ª–æ—Å—å –≤—Å—ë
        async function syncCloud(saveData = null) {
            try {
                if (saveData) {
                    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
                    await vkBridge.send('VKWebAppStorageSet', { key: 'sb_full_save', value: JSON.stringify(saveData) });
                } else {
                    // –ó–∞–≥—Ä—É–∑–∫–∞
                    const data = await vkBridge.send('VKWebAppStorageGet', { keys: ['sb_full_save'] });
                    if (data.keys && data.keys[0].value) {
                        return JSON.parse(data.keys[0].value);
                    }
                }
            } catch (e) { console.error("Cloud sync error", e); }
            return null;
        }

        async function saveProgress() {
            // –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π —Å–µ–π–≤
            const saveData = { 
                grid: gameOver ? [] : grid, // –ï—Å–ª–∏ –ø—Ä–æ–∏–≥—Ä–∞–ª, –ø–æ–ª–µ —á–∏—Å—Ç–æ–µ
                score: gameOver ? 0 : score,
                availablePieces, 
                stats, 
                timestamp: Date.now() 
            };
            // –õ–æ–∫–∞–ª—å–Ω–æ
            localStorage.setItem('sb_full_save', JSON.stringify(saveData));
            // –í –æ–±–ª–∞–∫–æ
            await syncCloud(saveData);
        }

        // --- –†–ï–ö–õ–ê–ú–ê ---
        function showBannerAd() {
            if (vkBridge.supports("VKWebAppShowBannerAd")) {
                vkBridge.send("VKWebAppShowBannerAd", { banner_location: "bottom" })
                .then((data) => { if (data.result) { bannerHeight = 60; resizeGame(); } })
                .catch(console.log);
            }
        }
        function showInterstitialAd() {
            if (vkBridge.supports("VKWebAppShowNativeAds")) {
                vkBridge.send("VKWebAppShowNativeAds", { ad_format: "interstitial" }).catch(console.log);
            }
        }
        function showRewardedAd(onSuccess) {
            if (vkBridge.supports("VKWebAppShowNativeAds")) {
                vkBridge.send("VKWebAppShowNativeAds", { ad_format: "reward" })
                .then((data) => { if (data.result) onSuccess(); })
                .catch((e) => { onSuccess(); });
            } else onSuccess();
        }

        // --- –ê–î–ê–ü–¢–ê–¶–ò–Ø ---
        function resizeGame() {
            const topH = topBar.offsetHeight;
            const bottomH = controlsArea.offsetHeight + bannerHeight; 
            const availableH = window.innerHeight - topH - bottomH - 10; 
            const availableW = window.innerWidth - 10;

            MICRO_PIXEL_SIZE = Math.min(availableW / MICRO_COLS, availableH / MICRO_ROWS);
            if (MICRO_PIXEL_SIZE < 2) MICRO_PIXEL_SIZE = 2;

            canvas.width = Math.floor(MICRO_COLS * MICRO_PIXEL_SIZE);
            canvas.height = Math.floor(MICRO_ROWS * MICRO_PIXEL_SIZE);
            
            gameWrapper.style.width = canvas.width + 'px';
            gameWrapper.style.height = canvas.height + 'px';
            
            controlsArea.style.paddingBottom = (10 + bannerHeight) + 'px';

            if (!grid || grid.length === 0) grid = Array.from({ length: MICRO_ROWS }, () => Array(MICRO_COLS).fill(0));
        }

        window.addEventListener('resize', () => { resizeGame(); draw(); });

        // --- –°–¢–ê–†–¢ ---
        async function bootGame() {
            resizeGame();
            showBannerAd();
            
            const isFirstRun = !localStorage.getItem('sb_tutorial_shown');
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±–ª–∞–∫–æ –∏ –ª–æ–∫–∞–ª–∫—É, –≤—ã–±–∏—Ä–∞–µ–º —Å–≤–µ–∂–µ–µ
            const cloudData = await syncCloud();
            const localDataStr = localStorage.getItem('sb_full_save');
            let localData = localDataStr ? JSON.parse(localDataStr) : null;
            
            let finalData = localData;
            // –ï—Å–ª–∏ –≤ –æ–±–ª–∞–∫–µ –Ω–æ–≤–µ–µ, –±–µ—Ä–µ–º –æ—Ç—Ç—É–¥–∞
            if (cloudData && (!localData || cloudData.timestamp > localData.timestamp)) {
                finalData = cloudData;
            }

            if (finalData && finalData.stats) stats = finalData.stats;

            if (isFirstRun) {
                localStorage.setItem('sb_tutorial_shown', 'true');
                init();
                startTutorialDirectly();
            } else if (finalData && finalData.score > 0 && finalData.grid && finalData.grid.length > 0) {
                document.getElementById('welcome-modal').style.display = 'flex';
                document.getElementById('welcome-continue-btn').onclick = () => {
                    document.getElementById('welcome-modal').style.display = 'none';
                    restoreGame(finalData);
                };
                document.getElementById('welcome-new-btn').onclick = () => {
                    document.getElementById('welcome-modal').style.display = 'none';
                    init();
                };
            } else {
                init();
            }
        }

        function startTutorialDirectly() {
            document.getElementById('tutorial-modal').style.display = 'flex';
            initTutorial();
        }

        function restoreGame(data) {
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            grid = data.grid;
            score = data.score;
            availablePieces = data.availablePieces || [];
            stats = data.stats || stats;
            gameOver = false; isPaused = false; isMagicActive = false; isClearingLines = false; isBoardStable = true;
            isDragging = false; selectedPieceIndex = -1;
            if (draggedPieceElement) { draggedPieceElement.remove(); draggedPieceElement = null; }
            resizeGame();
            updateScoreUI();
            drawPieceSelectors();
            draw();
            gameLoop();
        }

        function init() {
            if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
            resizeGame();
            grid = Array.from({ length: MICRO_ROWS }, () => Array(MICRO_COLS).fill(0));
            score = 0; gameOver = false; isPaused = false; isMagicActive = false; isClearingLines = false;
            pixelsToAnimate = []; isBoardStable = true; clearAnimationTimer = 0;
            isDragging = false; selectedPieceIndex = -1;
            if (draggedPieceElement) { draggedPieceElement.remove(); draggedPieceElement = null; }
            updateMagicState();
            updateScoreUI();
            generateNewPieces();
            document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
            draw();
            gameLoop();
            saveProgress(); 
        }

        function gameLoop() {
            if (gameOver) { gameLoopId = null; return; }
            if (isPaused) {
                if(tutorialRunning) updateTutorial();
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }
            if (!isClearingLines) {
                for (let i = 0; i < PHYSICS_ITERS_PER_FRAME; i++) {
                    if (!isBoardStable) updatePhysics(); else break;
                }
                if (isBoardStable) {
                    const pixelsToClear = findConnectedLines();
                    if (pixelsToClear.length > 0) startClearAnimation(pixelsToClear);
                }
            }
            draw();
            if (!isClearingLines) checkGameOver();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function updatePhysics() {
            let movedAny = false;
            physicsFrameParity = (physicsFrameParity + 1) % 2;
            for (let y = MICRO_ROWS - 2; y >= 0; y--) {
                const iterateLeftToRight = physicsFrameParity === 0;
                const startX = iterateLeftToRight ? 0 : MICRO_COLS - 1;
                const endX = iterateLeftToRight ? MICRO_COLS : -1;
                const stepX = iterateLeftToRight ? 1 : -1;
                for (let x = startX; x !== endX; x += stepX) {
                    if (grid[y][x] === 0) continue;
                    let moved = false;
                    if (grid[y + 1][x] === 0) {
                        grid[y + 1][x] = grid[y][x]; grid[y][x] = 0; moved = true;
                    } else {
                        const dir = Math.random() < 0.5 ? 1 : -1;
                        if (checkAndMove(y, x, dir)) moved = true;
                        else if (checkAndMove(y, x, -dir)) moved = true;
                    }
                    if (moved) movedAny = true;
                }
            }
            isBoardStable = !movedAny;
        }

        function checkAndMove(y, x, dir) {
            const newX = x + dir;
            if (newX >= 0 && newX < MICRO_COLS && grid[y + 1][newX] === 0) {
                grid[y + 1][newX] = grid[y][x]; grid[y][x] = 0; return true;
            }
            return false;
        }

        function startClearAnimation(pixels) {
            isClearingLines = true; pixelsToAnimate = pixels;
            clearAnimationTimer = CLEAR_ANIMATION_DURATION;
            playSound('combo');
            vibrate('success'); 
            const points = Math.floor(pixels.length * 1.5);
            addScore(points);
            showPopupText(`+${points}`, canvas.width/2, canvas.height/2);
            saveProgress();
        }

        function findConnectedLines() {
            const visited = Array.from({ length: MICRO_ROWS }, () => Array(MICRO_COLS).fill(false));
            const allPixelsToClear = [];
            for (let y = 0; y < MICRO_ROWS; y++) {
                for (let x = 0; x < MICRO_COLS; x++) {
                    if (grid[y][x] !== 0 && !visited[y][x]) {
                        const color = Math.abs(grid[y][x]);
                        const group = [];
                        const queue = [[y, x]];
                        visited[y][x] = true;
                        let minX = x, maxX = x;
                        while (queue.length > 0) {
                            const [curY, curX] = queue.shift();
                            group.push([curY, curX]);
                            minX = Math.min(minX, curX); maxX = Math.max(maxX, curX);
                            [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(([dy, dx]) => {
                                const nY = curY + dy, nX = curX + dx;
                                if (nY >= 0 && nY < MICRO_ROWS && nX >= 0 && nX < MICRO_COLS && !visited[nY][nX] && Math.abs(grid[nY][nX]) === color) {
                                    visited[nY][nX] = true; queue.push([nY, nX]);
                                }
                            });
                        }
                        if (minX === 0 && maxX === MICRO_COLS - 1) allPixelsToClear.push(...group);
                    }
                }
            }
            return allPixelsToClear;
        }

        function checkGameOver() {
            if (isBoardStable) {
                for(let r = 0; r < 3; r++) {
                    const rowToCheck = GAME_OVER_LINE_ROW - r;
                    if (rowToCheck >= 0) {
                        for (let x = 0; x < MICRO_COLS; x++) {
                            if (grid[rowToCheck][x] !== 0) {
                                endGame();
                                return;
                            }
                        }
                    }
                }
            }
        }

        function endGame() {
            if (gameOver) return;
            gameOver = true;
            stats.gamesPlayed++;
            if (score > stats.record) stats.record = score;
            saveProgress(); 
            finalScoreSpan.textContent = score;
            document.getElementById('gameover-modal').style.display = 'flex';
            vibrate('error');
            showInterstitialAd();
        }

        function generateNewPieces() {
            availablePieces = [];
            for (let i = 0; i < 3; i++) {
                const shape = PIECES[Math.floor(Math.random() * PIECES.length)].shape;
                // 1) –õ–æ–≥–∏–∫–∞ —Ü–≤–µ—Ç–æ–≤ –ø–æ —É—Ä–æ–≤–Ω—è–º
                let colorOptions = [1, 2, 3, 4]; // –ë–∞–∑–æ–≤—ã–µ
                if (score >= 25000) colorOptions.push(5); // –†–æ–∑–æ–≤—ã–π
                if (score >= 50000) colorOptions.push(6); // –ì–æ–ª—É–±–æ–π
                if (score >= 75000) colorOptions.push(7); // –û—Ä–∞–Ω–∂–µ–≤—ã–π
                if (score >= 100000) colorOptions.push(8); // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
                
                const color = colorOptions[Math.floor(Math.random() * colorOptions.length)];
                availablePieces.push({ shape, color });
            }
            drawPieceSelectors();
        }

        function activateMagic() {
            if (isMagicActive) { 
                isMagicActive = false; 
                updateMagicState(); 
            } else { 
                showRewardedAd(() => { 
                    isMagicActive = true; 
                    showPopupText("–ù–ê–ñ–ú–ò –ù–ê –¶–í–ï–¢!", canvas.width/2, canvas.height/3); 
                    updateMagicState(); 
                }); 
            }
        }
        
        // 3) –Ø–≤–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –º–∞–≥–∏–∏
        function updateMagicState() {
            if (isMagicActive) { 
                magicBtn.classList.add('active'); 
                magicBtn.innerHTML = '<svg class="icon-svg"><use xlink:href="#icon-magic"/></svg> –í–´–ë–ï–†–ò –¶–í–ï–¢';
                gameWrapper.classList.add('magic-active');
            } else { 
                magicBtn.classList.remove('active'); 
                magicBtn.innerHTML = '<svg class="icon-svg"><use xlink:href="#icon-magic"/></svg> <span class="ad-icon">AD</span>';
                gameWrapper.classList.remove('magic-active');
            }
        }

        function handleCanvasClick(e) {
            if (!isMagicActive) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / MICRO_PIXEL_SIZE);
            const y = Math.floor((e.clientY - rect.top) / MICRO_PIXEL_SIZE);
            if (x >= 0 && x < MICRO_COLS && y >= 0 && y < MICRO_ROWS) {
                const colorVal = Math.abs(grid[y][x]);
                if (colorVal !== 0) {
                    playSound('magic'); vibrate('heavy'); 
                    for(let r=0; r<MICRO_ROWS; r++) for(let c=0; c<MICRO_COLS; c++) if(Math.abs(grid[r][c]) === colorVal) grid[r][c] = 0;
                    isBoardStable = false; isMagicActive = false; updateMagicState(); saveProgress();
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            let animProgress = 1.0;
            if (isClearingLines) {
                clearAnimationTimer--;
                animProgress = clearAnimationTimer / CLEAR_ANIMATION_DURATION;
                if (clearAnimationTimer <= 0) {
                    pixelsToAnimate.forEach(([y, x]) => { grid[y][x] = 0; });
                    isClearingLines = false; pixelsToAnimate = []; isBoardStable = false;
                }
            }
            for (let y = 0; y < MICRO_ROWS; y++) {
                for (let x = 0; x < MICRO_COLS; x++) {
                    const val = grid[y][x];
                    if (val !== 0) {
                        let color = COLORS[Math.abs(val)];
                        if (isClearingLines && pixelsToAnimate.some(p => p[0]===y && p[1]===x)) {
                             ctx.globalAlpha = animProgress;
                             const size = MICRO_PIXEL_SIZE * animProgress;
                             const offset = (MICRO_PIXEL_SIZE - size) / 2;
                             ctx.fillStyle = color; ctx.fillRect(x * MICRO_PIXEL_SIZE + offset, y * MICRO_PIXEL_SIZE + offset, size, size);
                             ctx.globalAlpha = 1.0;
                        } else {
                            if (val < 0) color = darkenColor(color, -30);
                            ctx.fillStyle = color; ctx.fillRect(x * MICRO_PIXEL_SIZE, y * MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE);
                        }
                    }
                }
            }
            if (GAME_OVER_LINE_ROW) {
                ctx.beginPath(); ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2; ctx.shadowBlur = 8; ctx.shadowColor = "red";
                const yPos = GAME_OVER_LINE_ROW * MICRO_PIXEL_SIZE;
                ctx.moveTo(0, yPos); ctx.lineTo(canvas.width, yPos); ctx.stroke(); ctx.shadowBlur = 0;
            }
        }

        function drawPieceSelectors() {
            piecesContainer.innerHTML = '';
            availablePieces.forEach((piece, index) => {
                const preview = document.createElement('canvas');
                preview.className = 'piece-preview';
                preview.dataset.index = index;
                const blockSize = 18; 
                const w = piece.shape[0].length * blockSize;
                const h = piece.shape.length * blockSize;
                preview.width = w; preview.height = h;
                const pCtx = preview.getContext('2d');
                pCtx.fillStyle = COLORS[piece.color];
                for(let y=0; y<piece.shape.length; y++){
                    for(let x=0; x<piece.shape[y].length; x++){
                        if(piece.shape[y][x]) {
                            pCtx.fillRect(x*blockSize, y*blockSize, blockSize-1, blockSize-1);
                            pCtx.fillStyle = 'rgba(255,255,255,0.2)';
                            pCtx.fillRect(x*blockSize, y*blockSize, blockSize, blockSize/3);
                            pCtx.fillStyle = COLORS[piece.color];
                        }
                    }
                }
                piecesContainer.appendChild(preview);
            });
        }

        function handleDragStart(e) {
            if (gameOver || isPaused || isClearingLines || isMagicActive) return;
            if (!e.target.classList.contains('piece-preview')) return;
            e.preventDefault();
            playSound('pickup');
            vibrate('light'); 

            selectedPieceIndex = parseInt(e.target.dataset.index);
            const piece = availablePieces[selectedPieceIndex];
            isDragging = true;
            
            draggedPieceElement = document.createElement('canvas');
            draggedPieceElement.id = 'dragged-piece';
            const realWidth = piece.shape[0].length * MICRO_SCALE * MICRO_PIXEL_SIZE;
            const realHeight = piece.shape.length * MICRO_SCALE * MICRO_PIXEL_SIZE;
            draggedPieceElement.width = realWidth; draggedPieceElement.height = realHeight;
            const dCtx = draggedPieceElement.getContext('2d');
            const baseColor = COLORS[piece.color];
            for(let y=0; y<piece.shape.length; y++){
                for(let x=0; x<piece.shape[y].length; x++){
                    if(piece.shape[y][x]){
                         for(let r=0; r<MICRO_SCALE; r++){
                            for(let c=0; c<MICRO_SCALE; c++){
                                dCtx.fillStyle = Math.random() > 0.5 ? baseColor : darkenColor(baseColor, -30);
                                dCtx.fillRect((x*MICRO_SCALE+c)*MICRO_PIXEL_SIZE, (y*MICRO_SCALE+r)*MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE, MICRO_PIXEL_SIZE);
                            }
                         }
                    }
                }
            }
            document.body.appendChild(draggedPieceElement);
            const touch = e.touches ? e.touches[0] : e;
            updateDragPosition(touch.clientX, touch.clientY, !!e.touches);
        }

        function handleDragMove(e) {
            if (!isDragging || !draggedPieceElement) return;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            updateDragPosition(touch.clientX, touch.clientY, !!e.touches);
        }
        
        function updateDragPosition(clientX, clientY, isTouch) {
            const rect = canvas.getBoundingClientRect();
            const dw = draggedPieceElement.width;
            const dh = draggedPieceElement.height;
            let targetX = clientX - dw / 2;
            let targetY = isTouch ? (clientY - dh * 2.0) : (clientY - dh / 2);
            
            const minX = rect.left;
            const maxX = rect.right - dw;
            if (targetX < minX) targetX = minX;
            if (targetX > maxX) targetX = maxX;
            
            draggedPieceElement.style.left = targetX + 'px';
            draggedPieceElement.style.top = targetY + 'px';
            
            const relX = Math.round((targetX - rect.left) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            const relY = Math.round((targetY - rect.top) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            
            const piece = availablePieces[selectedPieceIndex];
            const valid = canPlacePiece(piece, relY, relX);
            draggedPieceElement.style.opacity = valid ? '1.0' : '0.5';
            draggedPieceElement.style.filter = valid ? `drop-shadow(0 0 5px ${COLORS[piece.color]})` : 'grayscale(100%)';
        }

        function handleDragEnd(e) {
            if (!isDragging) return;
            isDragging = false;
            const rect = canvas.getBoundingClientRect();
            const currentLeft = parseFloat(draggedPieceElement.style.left);
            const currentTop = parseFloat(draggedPieceElement.style.top);
            const dropX = Math.round((currentLeft - rect.left) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            const dropY = Math.round((currentTop - rect.top) / (MICRO_PIXEL_SIZE * MICRO_SCALE));
            
            const piece = availablePieces[selectedPieceIndex];
            if (canPlacePiece(piece, dropY, dropX)) {
                placePiece(piece, dropY, dropX);
                playSound('drop');
                vibrate('medium'); 
                availablePieces.splice(selectedPieceIndex, 1);
                if (availablePieces.length === 0) generateNewPieces();
                drawPieceSelectors();
                saveProgress();
            }
            if (draggedPieceElement) draggedPieceElement.remove(); draggedPieceElement = null;
        }

        function canPlacePiece(piece, dropY, dropX) {
            for(let y=0; y<piece.shape.length; y++) for(let x=0; x<piece.shape[y].length; x++) if(piece.shape[y][x]){
                const mx = (dropX + x) * MICRO_SCALE; const my = (dropY + y) * MICRO_SCALE;
                if (mx < 0 || mx + MICRO_SCALE > MICRO_COLS || my < 0 || my + MICRO_SCALE > MICRO_ROWS) return false;
                for (let r=0; r<MICRO_SCALE; r+=MICRO_SCALE-1) for(let c=0; c<MICRO_SCALE; c+=MICRO_SCALE-1) if (grid[my+r][mx+c] !== 0) return false;
            }
            return true;
        }

        function placePiece(piece, dropY, dropX) {
            isBoardStable = false;
            for(let y=0; y<piece.shape.length; y++) for(let x=0; x<piece.shape[y].length; x++) if(piece.shape[y][x]){
                const mx = (dropX + x) * MICRO_SCALE; const my = (dropY + y) * MICRO_SCALE;
                for(let r=0; r<MICRO_SCALE; r++) for(let c=0; c<MICRO_SCALE; c++) {
                    const val = piece.color; grid[my+r][mx+c] = Math.random() > 0.5 ? val : -val;
                }
            }
        }

        function updateScoreUI() {
            let currentLevelBase = Math.floor(score / 25000) * 25000;
            let nextGoal = currentLevelBase + 25000;
            let progress = ((score - currentLevelBase) / 25000) * 100;
            scoreText.textContent = `${score} / ${nextGoal}`;
            scoreFill.style.width = `${Math.min(100, progress)}%`;
            if (currentLevelBase >= 25000) scoreFill.style.background = 'linear-gradient(90deg, #FF00FF, #9d00b8)';
            else scoreFill.style.background = 'linear-gradient(90deg, #e94560, #ff6b6b)';
        }

        function addScore(points) { score += points; updateScoreUI(); }
        function showPopupText(text, x, y) {
            const el = document.createElement('div'); el.className = 'popup-text'; el.textContent = text;
            el.style.left = x + 'px'; el.style.top = y + 'px'; document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function generateLeaderboard() {
            const names = ["–ê–ª–µ–∫—Å–µ–π", "–ú–∞—Ä–∏—è", "–ò–≤–∞–Ω", "–ï–ª–µ–Ω–∞", "–î–º–∏—Ç—Ä–∏–π", "–û–ª—å–≥–∞", "–°–µ—Ä–≥–µ–π", "–ê–Ω–Ω–∞", "–ù–∏–∫–æ–ª–∞–π", "–¢–∞—Ç—å—è–Ω–∞"];
            const list = [];
            let topScore = 120000000 + Math.floor(Math.random() * 20000000);
            for(let i=0; i<5; i++) {
                let currentScore;
                if (i === 0) currentScore = topScore;
                else if (i === 4) currentScore = 2000000 + Math.floor(Math.random() * 500000);
                else currentScore = Math.floor(topScore / Math.pow(3, i)); 
                list.push({ rank: i+1, name: names[i], score: currentScore.toLocaleString('ru-RU') });
            }
            const displayScore = Math.max(score, stats.record);
            let playerRank = 10000 - Math.floor(displayScore / 800);
            if (playerRank < 1) playerRank = 1; if (playerRank > 10000) playerRank = 10000;
            const playerEntry = { rank: playerRank, name: "–í—ã", score: displayScore.toLocaleString('ru-RU'), isMe: true };
            const container = document.getElementById('leaderboard-list'); container.innerHTML = '';
            let displayList = [...list];
            if (playerRank > 5) { displayList.push({ rank: "...", name: "", score: "" }); displayList.push(playerEntry); }
            displayList.forEach(item => {
                const div = document.createElement('div'); div.className = `leaderboard-item ${item.isMe ? 'me' : ''}`;
                if (item.rank === "...") { div.innerHTML = `<span>...</span>`; div.style.border = "none"; }
                else div.innerHTML = `<span>#${item.rank} ${item.rank===1?'üèÜ':''} ${item.name}</span><span>${item.score}</span>`;
                container.appendChild(div);
            });
        }

        function darkenColor(hex, amount) {
            let usePound = false; if (hex[0] == "#") { hex = hex.slice(1); usePound = true; }
            let num = parseInt(hex, 16); let r = (num >> 16) + amount; let b = ((num >> 8) & 0x00FF) + amount; let g = (num & 0x0000FF) + amount;
            if (r > 255) r = 255; else if (r < 0) r = 0; if (b > 255) b = 255; else if (b < 0) b = 0; if (g > 255) g = 255; else if (g < 0) g = 0;
            return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6,'0');
        }

        function playSound(name) { if (settings.sound && sounds[name]) { sounds[name].currentTime = 0; sounds[name].play().catch(e => {}); } }
        
        function vibrate(type) {
            if (!settings.vibration) return;
            if (vkBridge.supports("VKWebAppTapticImpactOccurred")) {
                if (type === 'success') vkBridge.send("VKWebAppTapticNotificationOccurred", { type: "success" });
                else if (type === 'error') vkBridge.send("VKWebAppTapticNotificationOccurred", { type: "error" });
                else vkBridge.send("VKWebAppTapticImpactOccurred", { style: "light" }); 
            } else if (navigator.vibrate) {
                let pattern = 5; 
                if (type === 'medium') pattern = 8; 
                if (type === 'heavy') pattern = 15; 
                if (type === 'success') pattern = [15, 15, 15]; 
                if (type === 'error') pattern = [30, 15, 30]; 
                navigator.vibrate(pattern);
            }
        }

        document.addEventListener('contextmenu', event => event.preventDefault());
        document.body.addEventListener('click', () => { if(settings.sound && sounds.bg.paused) playSound('bg'); }, {once: true});

        magicBtn.addEventListener('click', activateMagic);
        canvas.addEventListener('click', handleCanvasClick);
        document.getElementById('pause-btn').addEventListener('click', () => { isPaused = true; tutorialRunning = false; document.getElementById('stat-games').textContent = stats.gamesPlayed; document.getElementById('stat-record').textContent = stats.record; document.getElementById('menu-modal').style.display = 'flex'; });
        document.getElementById('resume-btn').addEventListener('click', () => { document.getElementById('menu-modal').style.display = 'none'; isPaused = false; });
        document.getElementById('restart-menu-btn').addEventListener('click', init);
        document.getElementById('restart-btn').addEventListener('click', init);
        document.getElementById('rank-btn').addEventListener('click', () => { isPaused = true; generateLeaderboard(); document.getElementById('rank-modal').style.display = 'flex'; });
        document.getElementById('close-rank-btn').addEventListener('click', () => { document.getElementById('rank-modal').style.display = 'none'; isPaused = false; });
        
        // 3) –õ–æ–≥–∏–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞
        document.getElementById('games-btn').addEventListener('click', () => {
            isPaused = true;
            const list = document.getElementById('games-list');
            list.innerHTML = '';
            GAMES_CATALOG.forEach(game => {
                const card = document.createElement('div');
                card.className = 'game-card';
                card.innerHTML = `<img src="${game.img}" class="game-img" alt="${game.name}"><div class="game-title">${game.name}</div>`;
                card.onclick = () => vkBridge.send('VKWebAppShowApp', { app_id: game.id });
                list.appendChild(card);
            });
            document.getElementById('games-modal').style.display = 'flex';
        });
        document.getElementById('close-games-btn').addEventListener('click', () => {
            document.getElementById('games-modal').style.display = 'none';
            isPaused = false;
        });

        document.getElementById('tutorial-btn').addEventListener('click', () => { document.getElementById('menu-modal').style.display = 'none'; document.getElementById('tutorial-modal').style.display = 'flex'; initTutorial(); });
        document.getElementById('close-tutorial-btn').addEventListener('click', () => { document.getElementById('tutorial-modal').style.display = 'none'; if (!localStorage.getItem('sb_tutorial_shown')) { localStorage.setItem('sb_tutorial_shown', 'true'); init(); } else { isPaused = false; } tutorialRunning = false; });
        document.getElementById('sound-toggle').addEventListener('change', (e) => { settings.sound = e.target.checked; if(settings.sound) sounds.bg.play(); else sounds.bg.pause(); });
        document.getElementById('vibration-toggle').addEventListener('change', (e) => { settings.vibration = e.target.checked; });

        piecesContainer.addEventListener('mousedown', handleDragStart);
        piecesContainer.addEventListener('touchstart', handleDragStart, { passive: false });
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);

        // --- 2) –ù–û–í–û–ï –î–ï–¢–ê–õ–¨–ù–û–ï –û–ë–£–ß–ï–ù–ò–ï ---
        let tutorialRunning = false;
        let tutorialLoopId = null;
        let tutCanvas, tutCtx;
        let tutStep = 0;
        let tutTimer = 0;
        
        // –°–µ—Ç–∫–∞ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è 
        let tutGrid = []; 
        const TUT_ROWS = 35;
        const TUT_COLS = 30;

        function initTutorial() {
            if (tutorialLoopId) cancelAnimationFrame(tutorialLoopId);
            
            tutCanvas = document.getElementById('tutorial-canvas');
            tutCtx = tutCanvas.getContext('2d');
            tutorialRunning = true;
            tutStep = 0; 
            tutTimer = 0;
            // –û—á–∏—â–∞–µ–º —Å–µ—Ç–∫—É –æ–±—É—á–µ–Ω–∏—è
            tutGrid = Array.from({length: TUT_ROWS}, () => Array(TUT_COLS).fill(0));
            updateTutorial();
        }

        function updateTutorial() {
            if (!tutorialRunning) return;
            
            // –û—á–∏—Å—Ç–∫–∞
            tutCtx.fillStyle = '#000';
            tutCtx.fillRect(0, 0, tutCanvas.width, tutCanvas.height);

            // –¢–∞–π–º–µ—Ä (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —à–∞–≥)
            tutTimer += 0.5;
            
            const handX_start = 40; 
            const handX_end = 100;
            const handY = 40; 
            const blockY_end = 220; // –ö—É–¥–∞ –ø–∞–¥–∞–µ—Ç
            const T_SCALE = 8; // –†–∞–∑–º–µ—Ä –ø–∏–∫—Å–µ–ª—è

            // --- –§–ò–ó–ò–ö–ê –ü–ï–°–ö–ê (–≤–Ω—É—Ç—Ä–∏ –æ–±—É—á–µ–Ω–∏—è) ---
            // –ü—Ä–æ—Å—Ç–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º –æ—Å—ã–ø–∞–Ω–∏—è –¥–ª—è tutGrid
            for (let y = TUT_ROWS - 2; y >= 0; y--) {
                for (let x = 0; x < TUT_COLS; x++) {
                    if (tutGrid[y][x] !== 0) {
                        // –ü—ã—Ç–∞–µ–º—Å—è —É–ø–∞—Å—Ç—å –≤–Ω–∏–∑
                        if (tutGrid[y+1][x] === 0) {
                            tutGrid[y+1][x] = tutGrid[y][x];
                            tutGrid[y][x] = 0;
                        } 
                        // –ò–ª–∏ —Å–∫–∞—Ç–∏—Ç—å—Å—è
                        else {
                            const dir = Math.random() > 0.5 ? 1 : -1;
                            if (x + dir >= 0 && x + dir < TUT_COLS && tutGrid[y+1][x+dir] === 0) {
                                tutGrid[y+1][x+dir] = tutGrid[y][x];
                                tutGrid[y][x] = 0;
                            }
                        }
                    }
                }
            }

            // --- –°–¶–ï–ù–ê–†–ò–ô ---
            const textEl = document.getElementById('tutorial-text');

            if (tutStep === 0) { 
                textEl.textContent = "–í–æ–∑—å–º–∏ —Ñ–∏–≥—É—Ä—É";
                // –†–∏—Å—É–µ–º —Ä—É–∫—É –Ω–∞–¥ –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–µ–π
                drawHandWithBlock(handX_start, handY, false);
                if (tutTimer > 40) { tutStep = 1; tutTimer = 0; }
            }
            else if (tutStep === 1) { 
                textEl.textContent = "–ü–µ—Ä–µ—Ç–∞—â–∏ –Ω–∞ –ø–æ–ª–µ";
                // –†—É–∫–∞ –¥–≤–∏–∂–µ—Ç—Å—è –∫ —Ü–µ–Ω—Ç—Ä—É
                const progress = Math.min(tutTimer / 60, 1);
                const curX = handX_start + (handX_end - handX_start) * progress;
                drawHandWithBlock(curX, handY, false);
                if (tutTimer > 70) { tutStep = 2; tutTimer = 0; }
            }
            else if (tutStep === 2) { 
                textEl.textContent = "–û—Ç–ø—É—Å—Ç–∏ - –æ–Ω–∞ —Ä–∞—Å—Å—ã–ø–ª–µ—Ç—Å—è!";
                // –ë–ª–æ–∫ –ø–∞–¥–∞–µ—Ç
                const progress = Math.min(tutTimer / 40, 1);
                const curY = handY + 25 + (blockY_end - (handY + 25)) * progress;
                
                if (progress < 1) {
                    // –ü–∞–¥–∞–µ—Ç –∫–∞–∫ —Ü–µ–ª–æ–µ
                    drawBlock(handX_end, curY, false);
                } else {
                    // "–í–∑—Ä—ã–≤" –≤ –ø–µ—Å–æ–∫: –ø–µ—Ä–µ–Ω–æ—Å–∏–º –±–ª–æ–∫ –≤ —Å–µ—Ç–∫—É tutGrid
                    // –†–∏—Å—É–µ–º –±–ª–æ–∫ 4x4 –∫–ª–µ—Ç–∫–∏ –ø–æ 8px (32x32)
                    const startGx = Math.floor(handX_end / T_SCALE);
                    const startGy = Math.floor(blockY_end / T_SCALE);
                    
                    for(let r=0; r<4; r++) {
                        for(let c=0; c<4; c++) {
                            if(startGy+r < TUT_ROWS && startGx+c < TUT_COLS) {
                                tutGrid[startGy+r][startGx+c] = 1; // 1 = –∑–µ–ª–µ–Ω—ã–π
                            }
                        }
                    }
                    tutStep = 3; tutTimer = 0;
                }
            }
            else if (tutStep === 3) { 
                textEl.textContent = "–°–æ–±–µ—Ä–∏ –ª–∏–Ω–∏—é –æ–¥–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞";
                // –ñ–¥–µ–º, –ø–æ–∫–∞ –ø–µ—Å–æ–∫ –æ—Å—è–¥–µ—Ç (—Ç–∞–π–º–µ—Ä), –ø–æ—Ç–æ–º —Å–ø–∞–≤–Ω–∏–º –ª–∏–Ω–∏—é
                if (tutTimer > 100) { 
                    // –°–ø–∞–≤–Ω–∏–º –ª–∏–Ω–∏—é –≤–Ω–∏–∑—É (—Ü–≤–µ—Ç 2 = –∫—Ä–∞—Å–Ω—ã–π)
                    for(let x=0; x<TUT_COLS; x++) tutGrid[TUT_ROWS-1][x] = 2;
                    tutStep = 4; tutTimer = 0; 
                }
            }
            else if (tutStep === 4) { 
                // –ú–∏–≥–∞–Ω–∏–µ –∏ –æ—á–∏—Å—Ç–∫–∞
                if (Math.floor(tutTimer / 10) % 2 === 0) { 
                     // –†–∏—Å—É–µ–º –±–µ–ª—É—é –ø–æ–ª–æ—Å—É –ø–æ–≤–µ—Ä—Ö –ª–∏–Ω–∏–∏
                     tutCtx.fillStyle = 'rgba(255,255,255,0.8)';
                     tutCtx.fillRect(0, (TUT_ROWS-1) * T_SCALE, TUT_COLS * T_SCALE, T_SCALE);
                }
                if (tutTimer > 60) { 
                    // –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å–µ—Ç–∫–∏
                    tutGrid = Array.from({length: TUT_ROWS}, () => Array(TUT_COLS).fill(0));
                    tutStep = 0; tutTimer = 0; 
                }
            }

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ tutGrid
            for (let y = 0; y < TUT_ROWS; y++) {
                for (let x = 0; x < TUT_COLS; x++) {
                    const val = tutGrid[y][x];
                    if (val !== 0) {
                        // 1 - –ó–µ–ª–µ–Ω—ã–π (–Ω–∞—à –±–ª–æ–∫), 2 - –ö—Ä–∞—Å–Ω—ã–π (–ª–∏–Ω–∏—è)
                        tutCtx.fillStyle = val === 1 ? '#33FF33' : '#FF3333';
                        tutCtx.fillRect(x * T_SCALE, y * T_SCALE, T_SCALE, T_SCALE);
                    }
                }
            }
            
            // –†–∏—Å—É–µ–º "–ø–æ–ª"
            tutCtx.fillStyle = '#555';
            tutCtx.fillRect(0, TUT_ROWS * T_SCALE, TUT_COLS * T_SCALE, 10);

            if (tutorialRunning) {
                tutorialLoopId = requestAnimationFrame(updateTutorial);
            }
        }

        function drawHandWithBlock(x, y, isSand) {
            // –†—É–∫–∞ (—Ç–µ–∫—Å—Ç/—ç–º–æ–¥–∑–∏)
            tutCtx.font = "40px Arial"; 
            tutCtx.fillStyle = "white"; 
            tutCtx.fillText("üëÜ", x + 15, y + 60);
            // –ë–ª–æ–∫ –ø–æ–¥ –ø–∞–ª—å—Ü–µ–º
            drawBlock(x, y, isSand);
        }
        
        // –†–∏—Å—É–µ–º –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–ª–æ–∫
        function drawBlock(x, y, isSand) {
            const pixelSize = 8;
            const gridSize = 4; // 4x4 –º–∏–∫—Ä–æ–ø–∏–∫—Å–µ–ª—è
            
            tutCtx.fillStyle = '#33FF33';
            
            // –†–∏—Å—É–µ–º –ø–æ–ø–∏–∫—Å–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã –±—ã–ª–æ –ø–æ—Ö–æ–∂–µ –Ω–∞ –ø–µ—Å–æ–∫
            for(let i=0; i<gridSize; i++) {
                for(let j=0; j<gridSize; j++) {
                    // –ù–µ–±–æ–ª—å—à–æ–π –∑–∞–∑–æ—Ä –¥–ª—è –≤–∏–¥–∞ "–ø–µ—Å—á–∏–Ω–æ–∫"
                    tutCtx.fillRect(x + j*pixelSize, y + i*pixelSize, pixelSize-0.5, pixelSize-0.5);
                }
            }
            
            // –û–±–≤–æ–¥–∫–∞ –¥–ª—è —Ü–µ–ª—å–Ω–æ—Å—Ç–∏, –ø–æ–∫–∞ –ª–µ—Ç–∏—Ç
            if (!isSand) {
                 tutCtx.strokeStyle = 'white'; 
                 tutCtx.lineWidth = 1;
                 tutCtx.strokeRect(x, y, gridSize*pixelSize, gridSize*pixelSize);
            }
        }

        bootGame();
    </script>
</body>
</html>
